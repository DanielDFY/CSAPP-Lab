# Cache Lab

The lab has two parts. In Part A we will implement a cache simulator. In Part B we will write a matrix transpose function that is optimized for cache performance. 

* [Part A](#partA)
* [Part B](#partB)

The traces subdirectory of the handout directory contains a collection of *reference trace files* that will be used to evaluate the correctness of the cache simulator in Part A. The trace files are generated by a Linux program called `valgrind`. The memory traces have the following form:

```
I 0400d7d4,8
 M 0421c7f0,4
 L 04f6b868,8
 S 7ff0005c8,8
```

Each line denotes one or two memory accesses. The format of each line is:

```
[space]operation address,size  
```

The *operation* field denotes the type of memory access: `I` denotes an instruction load, `L` a data load, `S` a data store, and `M` a data modify (i.e., a data load followed by a data store). There is never a space before each `I`. There is always a space before each `M`, `L`, and `S`. The *address* field specifies a 64-bit hexadecimal memory address. The *size* field specifies the number of bytes accessed by the operation. 

<h2 id = "partA">Part A</h2>
In Part A we will write a cache simulator in `csim.c` that takes a valgrind memory trace as input, simulates the hit/miss behavior of a cache memory on this trace, and outputs the total number of hits, misses, and evictions. 

Our simulator should perform the same as `csim-ref`. It uses the LFU (least-frequently used) replacement policy when choosing which cache line to evict.

The final source code are as follows with comments as detailed explanations.

```c
#include "cachelab.h"

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <getopt.h>
#include <string.h>
#include <limits.h>

int v;                  // optional verbose flag
int s, E, b, S;         // cache configs
char t[1000];           // trace file name
int hit_count, miss_count, eviction_count;  // printSummary arguments

typedef struct {
    int valid_bit;
    int tag;
    int time_stamp;
} cache_line, *cache_asso, **cache;  // simulate cache structure

cache _cache_ = NULL;  // cache instance

void printUsage() {
    printf("Usage: ./csim-ref [-hv] -s <num> -E <num> -b <num> -t <file>\n"
            "Options:\n"
            "  -h         Print this help message.\n"
            "  -v         Optional verbose flag.\n"
            "  -s <num>   Number of set index bits.\n"
            "  -E <num>   Number of lines per set.\n"
            "  -b <num>   Number of block offset bits.\n"
            "  -t <file>  Trace file.\n"
            "\n"
            "Examples:\n"
            "  linux>  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n"
            "  linux>  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n");
}

void printErrorOption(char err_char) {
    printf("./csim-ref: invalid option -- '%c'\n", err_char);
    printUsage();
}

void printErrorConfig() {
    printf("Segmentation fault (core dumped)");
}

void initCache() {
    _cache_ = (cache)malloc(sizeof(cache_asso) * S);
    for (int i = 0; i < S; ++i) {
        _cache_[i] = (cache_asso)malloc(sizeof(cache_line) * E);
        for(int j = 0; j < E; ++j) {
            _cache_[i][j].valid_bit = 0;
            _cache_[i][j].tag = -1;
            _cache_[i][j].time_stamp = -1;
        }
    }
}

void updateCache(unsigned int addr) {
    int set_index = (addr >> b) & ((-1U) >> (64 - s));
    int tag = addr >> (b + s);

    int empty_index = -1;
    int evict_index = -1;
    int max_stamp = INT_MIN;

    for (int i = 0; i < E; ++i) {
        if (_cache_[set_index][i].valid_bit == 0) {
            // record empty cache line
            empty_index = i;
        } else if (_cache_[set_index][i].tag == tag) {
            // if hit, reset time stamp, increase hit count
            _cache_[set_index][i].time_stamp = 0;
            ++hit_count;
            if (v) {
                printf(" hit");
            }
            return;
        } else if (_cache_[set_index][i].time_stamp > max_stamp) {
            evict_index = i;
            max_stamp = _cache_[set_index][i].time_stamp;
        }
    }

    ++miss_count;   // cache miss
    if (v) {
        printf(" miss");
    }

    if (empty_index != -1) {
        // if there is an empty line for new entry
        _cache_[set_index][empty_index].valid_bit = 1;
        _cache_[set_index][empty_index].tag = tag;
        _cache_[set_index][empty_index].time_stamp = 0;
    } else if (evict_index != -1) {
        // no emtpy line, replace LFU entry
        _cache_[set_index][evict_index].valid_bit = 1;
        _cache_[set_index][evict_index].tag = tag;
        _cache_[set_index][evict_index].time_stamp = 0;
	    
        ++eviction_count;
        if (v) {
            printf(" eviction");
        }
    } else {
        printf("Error: abnormal cache state!\n");
        exit(-1);
    }
}

void updateTimeStamp() {
	for(int i = 0; i < S; ++i)
        for(int j = 0; j < E; ++j)
            if(_cache_[i][j].valid_bit == 1)
                ++_cache_[i][j].time_stamp;
}

void parseTrace() {
    FILE* fp = fopen(t, "r");
    if (NULL == fp) {
        printf("%s: No such file or directory", t);
        exit(-1);
    }

    char identifier;    // the type of memory access: 'I', 'L', 'M', 'S'
    unsigned int addr;  // 64-bit hexadecimal memory address
    int size;           // the number of bytes accessed by the operation

    while (fscanf(fp, " %c %xu,%d\n", &identifier, &addr, &size) > 0) {
        // ignore instruction loads 'I'
        int valid = identifier == 'L' || identifier == 'S' || identifier == 'M';
        if (v && valid) {
            printf("%c %x,%d", identifier, addr, size / 16);
        }

        switch (identifier) {
            // a data load followed by a data store
            case 'M':
                updateCache(addr);
            
            // a data load or a data store
            case 'L':
            case 'S':   
                updateCache(addr);
        }
        updateTimeStamp();	// update time stamps

        if (v && valid) {
            printf("\n");
        }
    }
    
    fclose(fp);

    // free cache
    for (int i = 0; i < S; ++i) {
        free(_cache_[i]);
    }
    free(_cache_);
}

int main(int argc, char* argv[])
{
    v = 0;          // optional verbose flag that displays trace info
    hit_count = miss_count = eviction_count = 0;    // init counters

    int opt;        // return value of getopt
    while(-1 != (opt = getopt(argc, argv, "hvs:E:b:t:"))) {
        switch (opt) {
        case 'h':
            printUsage();
            return 0;
        case 'v':
            v = 1;
            break;
        case 's':
            s = atoi(optarg);
            break;
        case 'E':
            E = atoi(optarg);
            break;
        case 'b':
            b = atoi(optarg);
            break;
        case 't':
            strcpy(t, optarg);
            break;
        default:
            printErrorOption(opt);
            return -1;
        }
    }

    // check arguments
    if(s <= 0 || E <= 0 || b <= 0 || t == NULL) {
        printErrorConfig();
	    return -1;
    }

    S = 1 << s;     // S = 2^s

    initCache();
    parseTrace();

    printSummary(hit_count, miss_count, eviction_count);
    return 0;
}
```

Test result:

```
> ./test-csim
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27

TEST_CSIM_RESULTS=27
```

<h2 id = "partB">Part B</h2>
In Part B we will write a transpose function in `trans.c` that causes as few cache misses as possible.

The given cache config: s = 5, b = 5, E = 1. So there are 32 sets in the cache. Each cache set has 1 line with 32 storage bytes.

There are also some limitations:

* We are allowed to define at most 12 local variables of type int per transpose function.
* We are not allowed to side-step the previous rule by using any variables of type long or by using any bit tricks to store more than one value to a single variable. 
* Our transpose function may not use recursion. 
* If we choose to use helper functions, you may not have more than 12 local variables on the stack at a time between your helper functions and your top level transpose function.
* Our transpose function may not modify array A. However, we can do whatever we want with the contents of array B. 
* We are NOT allowed to define any arrays in your code or to use any variant of `malloc`. 

We will mainly use **blocking** to reduce cache misses.

### 32×32

The first testing matrix is 32 × 32. Because an int has 4 bytes and a cache line has 32 bytes, 8 ints can be put in 1 cache line. In the matrix, a row has 32 ints, which consume 4 cache lines. Then the whole cache can store 8 rows of the matrix. So 8 × 8 submatrices can be efficient to do blocking.

```c
int i, j, m, n;
for (i = 0; i < N; i += 8)
    for (j = 0; j < M; j += 8)
        for (n = i; n < i + 8; ++n)
            for (m = j; m < j + 8; ++m) {
                B[m][n] = A[n][m];
            }
```

Consider the algorithm above. During the transpoing, despite of the cold misses, there will be a conflict miss when the entry is on the diagonal. For example, when copying $A_{44}$, row 3 in A will be put in the cache, but then to write the entry into $B_{44}$, row 3 in B will bring an eviction. And $A_{45}$ will also bring another miss.

To reduce misses, we can read the whole line of the matrix before we write. 

```c
int i, j, k;
int x[8];
for (j = 0; j < M; j += 8) {
    for (i = 0; i < N; ++i) {
    // read 8 entries from A
        for (k = 0; k < 8; ++k)
            x[k] = A[i][j + k];
    // transpose these entries
        for (k = 0; k < 8; ++k)
            B[j + k][i] = x[k];
	}
}
```

However, this method can not get rid of all the confilt misses. After transpossing row i of A into column i of B, row i + 1 of B has been put in the cache. It will be evicted by row i + 1 of A and reoccupy that cache line when writing into column i + 1.

To avoid this, we must read row i + 1 of A before we write column i of B. Because of the variable amount limitation, the only way to store row i of A seems to make use of the space in B. We can temporarily store the entries in row i of B.

```c
int i, j, m, n;
int x[8];
for (i = 0; i < N; i += 8) {
    for (j = 0; j < M; j += 8) {
        if (i != j) {
            for (n = i; n < (i + 8); ++n)
                for (m = j; m < (j + 8); ++m)
                    B[m][n] = A[n][m];
        } else {
            for (n = 0; n < 8; ++n) {
                for (m = 0; m < 8; ++m)
                    x[m] = A[i + n][j + m];

                for (m = 0; m < n; ++m)
                    B[i + n][j + m] = B[i + m][j + n];

                for (m = 0; m < 8; ++m) {
                    if (m < n) {
                        B[i + m][j + n] = x[m];
                    } else {
                        B[i + n][j + m] = x[m];
                    }
                }
            }
        }
    }
}
```

Test result:

```
> ./test-trans -M 32 -N 32
Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:2018, misses:261, evictions:229

Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151

Summary for official submission (func 0): correctness=1 misses=261

TEST_TRANS_RESULTS=1:261
```

### 64×64

Under this case, the method above will not be efficient because row 0 and row 4 will be mapped to the same cache line. Therefore, an 8 × 8 submatrix needs to be divided further into 4 × 4 submatrices.

The solution is divided into 2 parts:

* Deal with the submatrices on the diagonal.
  * Copy these blocks from A into the non-diagonal parts of B.
  * Do transpoing and move them to correct positions.
* Deal the rest submatrices (No conflict between A and B for the related blocks).
  * 4 ×4 blocks: TL(top left), TR(top right), BL(bottom left), BR(bottom right)
  * Transpose TLs of A and B to correct blocks respectively. When complete both TLs will be in the cache.
  * Transpose TL of A then put it into TR of B.
  * Copy the first line of TR of B into 4 local variables, then fetch the related row in A into this line.
  * Put the 4 entries into the first line of BL of B.
  * Repeat the two steps above until BL of B completes transposition.
  * Transpose BR of A into BR of B.

```c
int i, j, m, n;
int x[4];

// diagonal blocks
for (i = 0; i < M; i += 8) {
    if (i + 8 >= M) {
        // last block
        j = i - 8;
    } else {
        j = i + 8;
    }

	// copy diagonal blocks of A to non-diagonal blocks of B
    for (m = 0; m < 8; ++m) {
        for (n = 0; n < 8; ++n) {
            B[i + m][j + n] = A[i + m][i + n];
        }
    } 
	
	// transpose copied blocks to diagonal blocks of B	
    for (m = 0; m < 4; ++m) {
        for (n = 0; n < 4; ++n) {
            B[i + m][i + n] = B[i + n][j + m];
            B[i + m][i + n + 4] = B[i + m][j + n + 4];						
        }
    }
	
    for (m = 0; m < 4; ++m) {
        for (n = 0; n < 4; ++n) {
            B[i + m + 4][j + n] ^= B[i + n][i + m + 4];
            B[i + n][i + m + 4] ^= B[i + m + 4][j + n];
            B[i + m + 4][j + n] ^= B[i + n][i + m + 4];
        }
    }
		
    for (m = 0; m < 4; ++m) {
        for (n = 0; n < 4; ++n) {
            B[i + m + 4][i + n] = B[i + m + 4][j + n];
            B[i + m + 4][i + n + 4] = B[i + n + 4][j + m + 4]; 
        }
    }
}

// non-diagonal blocks
for (j = 0; j + 8 <= N; j += 8) {
    for (i = 0; i + 8 <= M; i += 8) {
        if (i != j) {
            for (m = 0; m < 4; ++m) {
                for (n = 0; n < 4; ++n) {
                    B[i + n][j + m] = A[j + m][i + n];
                    B[i + n][j + m + 4] = A[j + m][i + n + 4];						
                }
            }

            for (m = 0; m < 4; ++m) {
                x[0] = B[i + m][j + 4];
                x[1] = B[i + m][j + 5];
                x[2] = B[i + m][j + 6];
                x[3] = B[i + m][j + 7];

            for(n = 0; n < 4; ++n){
                B[i + m][j + 4 + n] = A[j + 4 + n][i + m];
            }
		
                B[i + 4 + m][j] = x[0];
                B[i + 4 + m][j + 1] = x[1];
                B[i + 4 + m][j + 2] = x[2];
                B[i + 4 + m][j + 3] = x[3];
            }
			
            for (m = 0; m < 4; ++m) {
                for (n = 0; n < 4; ++n) {
                    B[i + 4 + n][j + 4 + m] = A[j + 4 + m][i + 4 + n]; 
                }
            }
        }	
    }
}
```

### 61×67

Because there should be at most 12 local variables, and the given matrix is asymmetric. We use the second method in 32 × 32 part and deal with the corner cases respectively.

```c
int i, j, k;
int x[8];
for (j = 0; j < (M - (M % 8)); j += 8) {
    for (i = 0; i < (N - (N % 8)); ++i) {
        for (k = 0; k < 8; ++k)
            x[k] = A[i][j + k];
        for (k = 0; k < 8; ++k)
            B[j + k][i] = x[k];
    }
}
        
for (i = 0; i < N; ++i) {
    j = M - (M % 8);
    for (k = 0; k < (M % 8); ++k) {
        x[k] = A[i][j + k];
    }
    for (k = 0; k < (M % 8); ++k) {
        B[j + k][i] = x[k];
    }
}
        
for (i = N - (N % 8); i < N; ++i) {
    for (j = 0; j < M; j += 8) {
        for (k = 0; k < 8 && (j + k) < M; ++k) {
            x[k] = A[i][j + k];
        }
        for (k = 0; k < 8 && (j + k) < M; ++k) {
            B[j + k][i] = x[k];
        }
    }
}
        
for (i = N - (N % 8); i < N; ++i) {
    j = M - (M % 8);
    for (k = 0; k < (M % 8); ++k) {
        x[k] = A[i][j + k];
    }
    for (k = 0; k < (M % 8); ++k) {
        B[j + k][i] = x[k];
    }
}
```

Test result:

```
> ./test-trans -M 61 -N 67
Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:6345, misses:1896, evictions:1864

Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (Simple row-wise scan transpose): hits:3756, misses:4423, evictions:4391

Summary for official submission (func 0): correctness=1 misses=1896

TEST_TRANS_RESULTS=1:1896
```



### Final Test

```
> ./driver.py
Part A: Testing cache simulator
Running ./test-csim
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27


Part B: Testing transpose function
Running ./test-trans -M 32 -N 32
Running ./test-trans -M 64 -N 64
Running ./test-trans -M 61 -N 67

Cache Lab summary:
                        Points   Max pts      Misses
Csim correctness          27.0        27
Trans perf 32x32           8.0         8         261
Trans perf 64x64           8.0         8        1157
Trans perf 61x67          10.0        10        1896
          Total points    53.0        53

```
